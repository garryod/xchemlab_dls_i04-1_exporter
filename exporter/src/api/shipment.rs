use super::proposals::Proposal;
use async_graphql::{Context, Object};
use derive_more::{Deref, DerefMut, From};
use models::{proposal, shipping};
use sea_orm::{
    ActiveValue::NotSet, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, QueryTrait, Set,
};

#[derive(Debug, Clone, From, Deref, DerefMut)]
pub struct Shipment(shipping::Model);

#[Object]
impl Shipment {
    async fn id(&self) -> &u32 {
        &self.shipping_id
    }

    async fn proposal(&self, ctx: &Context<'_>) -> async_graphql::Result<Option<Proposal>> {
        let database = ctx.data::<DatabaseConnection>()?;
        Ok(proposal::Entity::find_by_id(self.proposal_id)
            .one(database)
            .await?
            .map(Proposal::from))
    }

    async fn name(&self) -> &Option<String> {
        &self.shipping_name
    }

    async fn comments(&self) -> &Option<String> {
        &self.comments
    }
}

#[derive(Debug, Default)]
pub struct ShipmentQuery;

#[Object]
impl ShipmentQuery {
    async fn shipments(
        &self,
        ctx: &Context<'_>,
        proposal_id: Option<u32>,
    ) -> async_graphql::Result<Vec<Shipment>> {
        let database = ctx.data_unchecked::<DatabaseConnection>();
        shipping::Entity::find()
            .apply_if(proposal_id, |query, proposal_id| {
                query.filter(shipping::Column::ProposalId.eq(proposal_id))
            })
            .all(database)
            .await
            .map(|shippings| shippings.into_iter().map(Shipment::from).collect())
            .map_err(async_graphql::Error::from)
    }
}

#[derive(Debug, Default)]
pub struct ShipmentMutation;

#[Object]
impl ShipmentMutation {
    async fn create_shipment(
        &self,
        ctx: &Context<'_>,
        proposal_id: u32,
    ) -> async_graphql::Result<Shipment> {
        let database = ctx.data::<DatabaseConnection>()?;
        let model = shipping::ActiveModel {
            shipping_id: NotSet,
            proposal_id: Set(proposal_id),
            shipping_name: Set(Some("XChemLab Shipment".to_string())),
            delivery_agent_agent_name: NotSet,
            delivery_agent_shipping_date: NotSet,
            delivery_agent_delivery_date: NotSet,
            delivery_agent_agent_code: NotSet,
            delivery_agent_flight_code: NotSet,
            shipping_status: NotSet,
            bltime_stamp: NotSet,
            laboratory_id: NotSet,
            is_storage_shipping: NotSet,
            creation_date: NotSet,
            comments: Set(Some(
                "Automatically generated by XChemLab DLS i04-1 Exporter".to_string(),
            )),
            sending_lab_contact_id: NotSet,
            return_lab_contact_id: NotSet,
            return_courier: NotSet,
            date_of_shipping_to_user: NotSet,
            shipping_type: NotSet,
            safetylevel: NotSet,
            delivery_agent_flight_code_timestamp: NotSet,
            delivery_agent_label: NotSet,
            ready_by_time: NotSet,
            close_time: NotSet,
            physical_location: NotSet,
            delivery_agent_pickup_confirmation_timestamp: NotSet,
            delivery_agent_pickup_confirmation: NotSet,
            delivery_agent_ready_by_time: NotSet,
            delivery_agent_callin_time: NotSet,
            delivery_agent_productcode: NotSet,
            delivery_agent_flight_code_person_id: NotSet,
            extra: NotSet,
        };
        let model = shipping::Entity::insert(model).exec(database).await?;
        shipping::Entity::find_by_id(model.last_insert_id)
            .one(database)
            .await?
            .map(Shipment::from)
            .ok_or(async_graphql::Error::new(&format!(
                "Inserted model at {} but could not retrieve copy",
                model.last_insert_id
            )))
    }
}
